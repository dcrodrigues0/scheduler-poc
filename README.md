

## Schedule System with DynamoDB Integration - Proof of Concept (PoC)

### Overview:

This project serves as a Proof of Concept (PoC) for a simple Schedule System integrated with DynamoDB, developed using Spring Boot. The system is designed to manage schedules for various services, storing availability data for each service in a DynamoDB table.

## Database Model
- ### Table Schedule
| **Partition key**                 | fullname        | phone        | serviceType                | date          |
| --------------------------------- | --------------- | ------------ | -------------------------- | ------------- |
| PK (Auto generated random number) | Person fullname | Person phone | ID Reference Service table | Schedule date |

- ### Table Service
| **Partition key**                                                       | serviceName                                                              | availableDate                                                                                                                                                                                                      |
| ----------------------------------------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| PK (Auto generated random number)                                       | Is the service that will be scheduled ex: (Math class, Portuguese Class) | A map in format Map<String, List<String>> that contains the service available date as key and the available hours as values Ex: {"08/03/23":{"L":["18:00","19:00"]},"19/03/23":{"L":["08:00","19:00"]}}

> Data model can be loaded in aws using [Cloud formation](https://github.com/dcrodrigues0/scheduler-poc/tree/main/aws). 


# Integrate DynamoDB With Spring Boot

# About Dependencies

* ***aws-java-sdk-dynamodb** - Is the official maven repository
* ***spring-data-dynamodb** - Is the opensourcer maven repository that integrates DynamoDB with common spring boot practices (and allow us work with interface repository's) and also have the **aws-java-sdk-dynamodb** dependency inside.

## DynamoDB Configuration in Spring boot
* Is important create a configuration file for your dynamoDb that contains the aws dynamo builder to build a connection between AWS and your application, can be something like that:
```java
@Configuration  
@EnableDynamoDBRepositories(basePackageClasses = ScheduleRepository.class)  
public class DynamoDBConfig {  
  
    @Value("${aws.dynamodb.endpoint:http://localhost:8000}")  
    private String awsEndpoint;  
    @Value("${aws.accesskey:accesskey}")  
    private String awsAccessKey;  
    @Value("${aws.secretkey:secretkey}")  
    private String awsSecretKey;  
    @Value("${aws.region:us-east-1}")  
    private String awsRegion;  
  
    public AWSCredentialsProvider amazonAWSCredentialsProvider() {  
        return new AWSStaticCredentialsProvider(amazonAWSCredentials());  
    }  
  
    @Bean  
    public AWSCredentials amazonAWSCredentials() {  
        return new BasicAWSCredentials(awsAccessKey, awsSecretKey);  
    }  
  
    public EndpointConfiguration endpointConfiguration() {  
        return new EndpointConfiguration(awsEndpoint, awsRegion);  
    }  
  
    @Bean  
    public AmazonDynamoDB amazonDynamoDB() {  
        return AmazonDynamoDBClientBuilder.  
                standard()  
                .withCredentials(amazonAWSCredentialsProvider())  
                .withEndpointConfiguration(endpointConfiguration())  
                .build();  
    }  
  
}

```

> @EnableDynamoDBRepositories is an annotation from the ***spring-data-dynamodb

## DynamoDBClient vs DynamoDBMapper

* AWS DynamoDB SDK(***aws-java-sdk-dynamodb**) provides two ways to interact with DynamoDB: DynamoDBClient and DynamoDBMapper. if you would like to manual serialize and deserialize Java objects using libraries like Jackson or Gson DynamoDBClient will give you more flexibility to do, on the other hand DynamoDBMapper simplifies the process by automatically mapping Java objects to DynamoDB items and vice versa using annotations. DynamoDBMapper use annotation-based mapping: you can annotation your Java classes and fields with annotations like ‘@DynamoDBTable’, ‘DynamoDBHashKey’, ‘DynamoDBRangeKey’, etc., to define the mapping between Java objects and DynamoDB items.
  An example of mapping using DynamoDBMapper

```java
@DynamoDBTable(tableName = "Schedule")  
public class Schedule {  
  
    @DynamoDBHashKey(attributeName = "scheduleId")  
    @DynamoDBAutoGeneratedKey  
    private String scheduleId;  
  
    @DynamoDBAttribute(attributeName = "fullname")  
    private String fullname;  
    @DynamoDBAttribute(attributeName = "phone")  
    private String phone;  
    @DynamoDBAttribute(attributeName = "serviceType")  
    @DynamoDBTypeConverted(converter = ServiceTypeConverter.class)  
    private ServiceType serviceType;  
    @DynamoDBAttribute(attributeName = "date")  
    @DynamoDBTypeConverted(converter = LocalDateTimeConverter.class)  
    private LocalDateTime date;  
  
    public Schedule() {  
	    // Default constructor is required by AWS DynamoDB SDK
    }  
  
    public Schedule(String fullname, String phone, ServiceType serviceType, LocalDateTime date) {  
        this.fullname = fullname;  
        this.phone = phone;  
        this.serviceType = serviceType;  
        this.date = date;  
    }  
  
    public String getScheduleId() {  
        return scheduleId;  
    }  
  
    public String getFullname() {  
        return fullname;  
    }  
  
    public String getPhone() {  
        return phone;  
    }  
  
    public ServiceType getServiceType() {  
        return serviceType;  
    }  
  
    public LocalDateTime getDate() {  
        return date;  
    }  
  
    public void setScheduleId(String scheduleId) {  
        this.scheduleId = scheduleId;  
    }  
  
    public void setFullname(String fullname) {  
        this.fullname = fullname;  
    }  
  
    public void setPhone(String phone) {  
        this.phone = phone;  
    }  
  
    public void setServiceType(ServiceType serviceType) {  
        this.serviceType = serviceType;  
    }  
  
    public void setDate(LocalDateTime date) {  
        this.date = date;  
    }  
}
```

## Annotation on Model class
* When using DynamoDBMapper, two essential annotations must be provided on your model class: @DynamoDBTable and @DynamoDBHashKey.

```java 
@DynamoDBTable(tableName=) — required
```
> Refers which table the domain corresponds


```java 
@DynamoDBHashKey — required
```
> Use this annotation to map the partition key of your dynamoDb table If you have a sort key, you should use @DynamoDBRangeKey on it. For Global Secondary Index (GSI) key mapping, use

```java 
@DynamoDBAttribute
```
> This annotation maps the attribute in your object to attributes in the DynamoDB item.

```java 
@DynamoDBDocument
```
> This annotation is used in the AWS SDK for Java and DynamoDBMapper to mark a class as a nested document or complex type. When you annotation a Java class with @DynamoDBDocument, it indicates to DynamoDBMapper that instances of this class should be stored as nested attributes within other DynamoDB items.

```java 
@DynamoDBTypeConverterd(converter = )
```
> This annotation is used to specify a custom converter for attributes that do not directly map to standard Java types supported by DynamoDBMapper. For example, if you have a field in your Java class that is of a non-standard type, you can use @DynamoDBTypeConverted to provide a converter that knows how to convert that type to a format that DynamoDB can handle. And you need to implement a custom converter that implements. Example:

```java
// this is a converter for an enum type
public class ServiceTypeConverter implements DynamoDBTypeConverter<String, ServiceType> {  
  
    @Override  
    public String convert(ServiceType serviceType) {  
        return serviceType.name();  
    }  
  
    @Override  
    public ServiceType unconvert(String s) {  
        return ServiceType.valueOf(s);  
    }  
}
```

## Using Spring Data DynamoDB
* Spring data DynamoDB makes our life more easy because already integrate CrudRepository functionalities using interfaces in our application (similar to JPA Repository for relational databases).

Interface example with **spring-data-dynamodb**
```java
@EnableScan
public interface UserRepository extends CrudRepository<User, String> {
  List<User> findByLastName(String lastName);
  List<User> findByFirstName(String firstName);
}
```

Interface example just using aws sdk
```java
@Repository
@AllArgsConstructor
public class CustomerRepository {
    final private DynamoDBMapper dynamoDBMapper;

    public String createCustomer(Customer customer){
        dynamoDBMapper.save(customer);
        return customer.getId();
    }

    public Customer getCustomerById(String id){
        return dynamoDBMapper.load(Customer.class, id);
    }

    public Customer updateCustomer(String id, Customer customer){
        Customer load = dynamoDBMapper.load(Customer.class, id);
        // map these two entity
        load.setName(customer.getName());
        load.setAge(customer.getAge());
        load.setDob(customer.getDob());
        load.setContactList(customer.getContactList());
        load.setActiveFlag(customer.getActiveFlag());
        dynamoDBMapper.save(load);

        return dynamoDBMapper.load(Customer.class, id);
    }

    public String deleteCustomer(String id){
        Customer load = dynamoDBMapper.load(Customer.class, id);
        dynamoDBMapper.delete(load);
        return load.getId() + " get deleted !";
    }
}
```

## References
[Robin Chen - Integrate AWS DynamoDB with Spring Boot](https://medium.com/@sudacgb/integrate-aws-dynamodb-with-spring-boot-dc62b9ceae96) (Ty Mr Robin)

[Spring data DynamoDB Docs](https://github.com/derjust/spring-data-dynamodb?tab=readme-ov-file)


### Disclaimer
I know that there are a lot of features to implement in this PoC as log features, more robust logics inside services, unit tests and so on, but the goal here is a lightweight and simple PoC. Maybe in the future I can provide an upgrade. 
